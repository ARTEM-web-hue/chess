<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Quick Chess</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    #status {
      font-size: 24px;
      color: #555;
      margin-bottom: 20px;
      text-align: center;
    }
    #board {
      display: none;
      width: 95vw;
      max-width: 600px;
      height: 95vw;
      max-height: 600px;
      border: 2px solid #333;
    }
    .row {
      display: flex;
      height: 12.5%;
    }
    .square {
      width: 12.5%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: calc(95vw / 16);
      max-font-size: 40px;
      cursor: pointer;
      user-select: none;
    }
    .light { background: #f0d9b5; }
    .dark  { background: #b58863; }
    .selected { outline: 4px solid #0088cc; }
  </style>
</head>
<body>
  <div id="status">Подбираем соперника…</div>
  <div id="board"></div>

  <script>
    let myColor = null;
    let boardState = null;
    let selected = null;
    let gameOver = false;
    const ws = new WebSocket(`wss://${window.location.host}/ws`);

    const pieces = {
      'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
      'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };

    function fenToBoard(fen) {
      const board = Array(8).fill().map(() => Array(8).fill(null));
      const rows = fen.split(' ')[0].split('/');
      for (let r = 0; r < 8; r++) {
        let col = 0;
        for (let char of rows[r]) {
          if (!isNaN(char) && char !== '0') {
            col += parseInt(char);
          } else {
            board[r][col] = char;
            col++;
          }
        }
      }
      return board;
    }

    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';

      // Определяем, с чьей стороны смотрим
      const isWhiteView = (myColor === 'white');

      for (let visualRow = 0; visualRow < 8; visualRow++) {
        const rowEl = document.createElement('div');
        rowEl.className = 'row';

        for (let visualCol = 0; visualCol < 8; visualCol++) {
          // Преобразуем визуальные координаты в реальные (внутренние)
          const realRow = isWhiteView ? visualRow : 7 - visualRow;
          const realCol = isWhiteView ? visualCol : 7 - visualCol;

          const piece = boardState[realRow][realCol];
          const squareEl = document.createElement('div');
          squareEl.className = `square ${(visualRow + visualCol) % 2 === 0 ? 'light' : 'dark'}`;
          squareEl.dataset.vrow = visualRow;
          squareEl.dataset.vcol = visualCol;

          if (piece) {
            squareEl.textContent = pieces[piece] || '';
          }

          if (selected && selected.vrow === visualRow && selected.vcol === visualCol) {
            squareEl.classList.add('selected');
          }

          squareEl.onclick = () => handleSquareClick(visualRow, visualCol);
          rowEl.appendChild(squareEl);
        }
        boardEl.appendChild(rowEl);
      }
    }

    function handleSquareClick(vrow, vcol) {
      if (gameOver || !myColor || !boardState) return;

      const isWhiteView = (myColor === 'white');
      const realRow = isWhiteView ? vrow : 7 - vrow;
      const realCol = isWhiteView ? vcol : 7 - vcol;
      const piece = boardState[realRow][realCol];

      const isWhitePiece = piece && piece === piece.toUpperCase();
      const isBlackPiece = piece && piece === piece.toLowerCase();

      const isMyPiece = (myColor === 'white' && isWhitePiece) || (myColor === 'black' && isBlackPiece);

      if (isMyPiece) {
        selected = { vrow, vcol };
        renderBoard();
        return;
      }

      if (selected) {
        // Отправляем ход в формате UCI: e2e4
        const fromRealRow = isWhiteView ? selected.vrow : 7 - selected.vrow;
        const fromRealCol = isWhiteView ? selected.vcol : 7 - selected.vcol;

        const fromFile = String.fromCharCode(97 + fromRealCol);
        const fromRank = 8 - fromRealRow;
        const toFile = String.fromCharCode(97 + realCol);
        const toRank = 8 - realRow;

        const uciMove = fromFile + fromRank + toFile + toRank;
        ws.send(uciMove);

        selected = null;
        renderBoard();
      }
    }

    ws.onmessage = (event) => {
      const msg = event.data;

      if (msg.startsWith("color:")) {
        myColor = msg.split(":")[1];
        document.getElementById("status").style.display = "none";
        document.getElementById("board").style.display = "block";
        boardState = fenToBoard("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
        renderBoard();
      }
      else if (msg.startsWith("fen:")) {
        const fullFen = msg.split(":")[1];
        boardState = fenToBoard(fullFen);
        renderBoard();
      }
      else if (msg.startsWith("result:") || msg === "resign") {
        gameOver = true;
        alert("Игра окончена!");
        location.reload();
      }
    };

    ws.onclose = () => {
      if (!gameOver) alert("Соединение потеряно");
      location.reload();
    };
  </script>
</body>
</html>
